import os
import logging
from typing import Dict, List

from datasets import DatasetDict, load_dataset

from larm.data.builders.base_builder import BaseDatasetBuilder
from larm.data.interactions.singleturn_interaction import SingleTurnInteractionManager
from larm.common.registry import registry
from larm.data.envs.mm_math_env import MMMathEnv


@registry.register_builder("mm_math")
class MMMathBuilder(BaseDatasetBuilder):
    """
    MM Math dataset builder.
    
    Expects preprocessed data generated by scripts/mm_math_process.py
    with fields: prompt, completion, solution, image_path
    
    Expected directory structure:
        data_path/
          train.json   # preprocessed samples with prompt, completion, solution, image_path
          valid.json
          test.json
    """

    DATASET_CONFIG_DICT = {
        "default": "configs/datasets/mm_math/default.yaml",
    }
    CACHE_PATH = None

    def _build_datasets(self) -> DatasetDict:
        """Build SFT/RL datasets from preprocessed JSON files.
        
        The preprocessing (download, split, format) should be done via:
            python scripts/mm_math_process.py --config configs/latent_memory/mm_math.yaml
        
        Data is always loaded from 'data/mm_math' directory.
        """
        # Always use data/mm_math as the data path (unified location for both SFT and GRPO)
        data_path = "data/mm_math"

        # logging.info(f"[MM_Math] Using unified data path: {data_path}")

        # Load preprocessed splits
        data_files = {}
        for split_name in ["train", "valid", "test"]:
            json_path = os.path.join(data_path, f"{split_name}.json")
            if os.path.exists(json_path):
                data_files[split_name] = json_path

        if len(data_files) == 0:
            raise FileNotFoundError(
                f"No preprocessed data found in {data_path}. "
                f"Please run 'python scripts/mm_math_process.py --output_dir {data_path}' first."
            )

        # logging.info(f"[MM_Math] Loading preprocessed data from {data_path}")
        # logging.info(f"[MM_Math] Found splits: {list(data_files.keys())}")

        dataset_dict = load_dataset("json", data_files=data_files)

        # Apply max_samples if specified
        max_samples = getattr(self, 'full_config', {}).get("max_samples", None)
        if max_samples is None:
            max_samples = self.config.get("max_samples", None)

        if max_samples is not None and max_samples > 0:
            # logging.info(f"[MM_Math] Applying max_samples={max_samples}")
            for split_name in list(dataset_dict.keys()):
                original_size = len(dataset_dict[split_name])
                if original_size > max_samples:
                    dataset_dict[split_name] = dataset_dict[split_name].select(range(max_samples))
                    # logging.info(f"[MM_Math] {split_name}: {original_size} -> {len(dataset_dict[split_name])} samples")
                # else:
                    # logging.info(f"[MM_Math] {split_name}: keeping all {original_size} samples")

        # Verify expected fields
        required_fields = ["prompt", "completion", "solution", "image_path"]
        for split_name, ds in dataset_dict.items():
            missing_keys = set(required_fields) - set(ds.column_names)
            if missing_keys:
                raise ValueError(
                    f"Split '{split_name}' is missing required fields: {missing_keys}. "
                    f"Please regenerate preprocessed data using scripts/mm_math_process.py"
                )
            # logging.info(f"[MM_Math] {split_name}: {len(ds)} samples")

        # Adjust completion field based on mode
        # sft: use full solution text (completion field)
        # grpo: use extracted boxed answer (solution field)
        if self.mode == "grpo":
            # logging.info("[MM_Math] Mode: grpo - using solution field (boxed answer only)")
            for split_name in dataset_dict.keys():
                # For grpo, replace completion with solution (empty completion, solution has boxed answer)
                def use_solution(example):
                    example["completion"] = ""  # grpo generates from scratch
                    return example
                dataset_dict[split_name] = dataset_dict[split_name].map(use_solution)
        # else:
            # logging.info("[MM_Math] Mode: sft - using completion field (full solution text)")

        keep_keys = self._keep_keys()
        for split_name in dataset_dict.keys():
            dataset_dict[split_name] = dataset_dict[split_name].select_columns(keep_keys)

        # Log example
        if "train" in dataset_dict and len(dataset_dict["train"]) > 0:
            example = dataset_dict["train"][0]
            # logging.info(f"[MM_Math] Example after mode adjustment: {example}")

        return dataset_dict

    def _build_sft_datasets(self) -> DatasetDict:
        return self._build_datasets()

    def _build_rl_datasets(self) -> DatasetDict:
        return self._build_datasets()

    @classmethod
    def _keep_keys(cls) -> List[str]:
        """Required fields in preprocessed data."""
        return ["prompt", "completion", "solution", "image_path"]

    def get_env_cls(self):
        return MMMathEnv

    def get_generation_manager_cls(self):
        return SingleTurnInteractionManager
